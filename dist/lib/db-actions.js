"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBatchUserVideos = getBatchUserVideos;
exports.searchVideos = searchVideos;
exports.getUserAnalytics = getUserAnalytics;
exports.checkVideoExists = checkVideoExists;
exports.getUserMonthlyUsage = getUserMonthlyUsage;
exports.storeVideoAndSummary = storeVideoAndSummary;
exports.storeVideoAndSummaryWithTransaction = storeVideoAndSummaryWithTransaction;
exports.getUserSummaries = getUserSummaries;
exports.deleteVideoSummary = deleteVideoSummary;
exports.verifyVideoStorage = verifyVideoStorage;
const serverless_1 = require("@neondatabase/serverless");
// 🚀 PHASE 5.4: OPTIMIZED DATABASE CONNECTION WITH POOLING
const db_1 = require("./db"); // Use optimized connection
// Initialize database connection with pooling
const sql = (0, serverless_1.neon)(process.env.DATABASE_URL);
// 🚀 PHASE 5.4: OPTIMIZED QUERIES WITH PERFORMANCE TRACKING
// Helper function to ensure user exists in database with optimized query
async function ensureUserExists(userId, email, fullName) {
    try {
        // 🔍 OPTIMIZED: Single query with upsert instead of select + insert
        await (0, db_1.executeQuery)(async (sql) => {
            return await sql `
        INSERT INTO users (id, email, full_name, created_at, updated_at)
        VALUES (${userId}, ${email}, ${fullName || null}, NOW(), NOW())
        ON CONFLICT (id) 
        DO UPDATE SET
          email = EXCLUDED.email,
          full_name = COALESCE(EXCLUDED.full_name, users.full_name),
          updated_at = NOW()
      `;
        });
    }
    catch (error) {
        console.error('Error ensuring user exists:', error);
        throw new Error(`Failed to ensure user exists: ${error.message}`);
    }
}
// 🚀 OPTIMIZED: Batch operations for better performance
async function getBatchUserVideos(userIds, limit = 50) {
    try {
        return await (0, db_1.executeQuery)(async (sql) => {
            return await sql `
        SELECT 
          v.id,
          v.user_id,
          v.video_id,
          v.title,
          v.thumbnail_url,
          v.duration,
          v.created_at,
          vs.main_title,
          vs.overall_summary
        FROM videos v
        LEFT JOIN video_summaries vs ON v.id = vs.video_id
        WHERE v.user_id = ANY(${userIds})
        ORDER BY v.created_at DESC
        LIMIT ${limit}
      `;
        });
    }
    catch (error) {
        console.error('Error fetching batch user videos:', error);
        throw new Error(`Failed to fetch user videos: ${error.message}`);
    }
}
// 🚀 OPTIMIZED: Efficient video search with full-text search
async function searchVideos(query, userId, limit = 20) {
    try {
        return await (0, db_1.executeQuery)(async (sql) => {
            if (userId) {
                // User-specific search with ranking
                return await sql `
          SELECT 
            v.id,
            v.video_id,
            v.title,
            v.thumbnail_url,
            v.duration,
            vs.main_title,
            vs.overall_summary,
            -- Ranking based on relevance
            GREATEST(
              similarity(v.title, ${query}),
              similarity(vs.main_title, ${query}),
              similarity(vs.overall_summary, ${query})
            ) as relevance_score
          FROM videos v
          LEFT JOIN video_summaries vs ON v.id = vs.video_id
          WHERE v.user_id = ${userId}
          AND (
            v.title ILIKE '%' || ${query} || '%'
            OR vs.main_title ILIKE '%' || ${query} || '%'
            OR vs.overall_summary ILIKE '%' || ${query} || '%'
          )
          ORDER BY relevance_score DESC, v.created_at DESC
          LIMIT ${limit}
        `;
            }
            else {
                // Global search (for admin/analytics)
                return await sql `
          SELECT 
            v.video_id,
            v.title,
            COUNT(*) as process_count,
            AVG(vs.total_cost) as avg_cost
          FROM videos v
          LEFT JOIN video_summaries vs ON v.id = vs.video_id
          WHERE v.title ILIKE '%' || ${query} || '%'
          GROUP BY v.video_id, v.title
          ORDER BY process_count DESC
          LIMIT ${limit}
        `;
            }
        });
    }
    catch (error) {
        console.error('Error searching videos:', error);
        throw new Error(`Failed to search videos: ${error.message}`);
    }
}
// 🚀 OPTIMIZED: Analytics queries with proper indexing
async function getUserAnalytics(userId) {
    try {
        return await (0, db_1.executeQuery)(async (sql) => {
            // Single query with multiple CTEs for efficiency
            return await sql `
        WITH user_stats AS (
          SELECT 
            COUNT(DISTINCT v.id) as total_videos,
            SUM(vs.total_cost) as total_spent,
            AVG(vs.total_cost) as avg_cost_per_video,
            SUM(vs.total_tokens) as total_tokens,
            MAX(v.created_at) as last_activity
          FROM videos v
          LEFT JOIN video_summaries vs ON v.id = vs.video_id
          WHERE v.user_id = ${userId}
        ),
        monthly_usage AS (
          SELECT 
            DATE_TRUNC('month', v.created_at) as month,
            COUNT(*) as videos_processed,
            SUM(vs.total_cost) as monthly_cost
          FROM videos v
          LEFT JOIN video_summaries vs ON v.id = vs.video_id
          WHERE v.user_id = ${userId}
          AND v.created_at >= NOW() - INTERVAL '12 months'
          GROUP BY DATE_TRUNC('month', v.created_at)
          ORDER BY month DESC
        ),
        popular_channels AS (
          SELECT 
            v.channel_title,
            COUNT(*) as video_count,
            AVG(v.duration) as avg_duration
          FROM videos v
          WHERE v.user_id = ${userId}
          AND v.channel_title IS NOT NULL
          GROUP BY v.channel_title
          ORDER BY video_count DESC
          LIMIT 10
        )
        SELECT 
          (SELECT row_to_json(user_stats.*) FROM user_stats) as stats,
          (SELECT json_agg(monthly_usage.*) FROM monthly_usage) as monthly_usage,
          (SELECT json_agg(popular_channels.*) FROM popular_channels) as popular_channels
      `;
        });
    }
    catch (error) {
        console.error('Error fetching user analytics:', error);
        throw new Error(`Failed to fetch analytics: ${error.message}`);
    }
}
// 🚀 OPTIMIZED: Duplicate detection before processing
async function checkVideoExists(userId, videoId) {
    try {
        return await (0, db_1.executeQuery)(async (sql) => {
            const result = await sql `
        SELECT 
          v.id,
          v.created_at,
          vs.id as summary_id,
          vs.main_title,
          vs.total_cost
        FROM videos v
        LEFT JOIN video_summaries vs ON v.id = vs.video_id
        WHERE v.user_id = ${userId} AND v.video_id = ${videoId}
        LIMIT 1
      `;
            return result.length > 0 ? result[0] : null;
        });
    }
    catch (error) {
        console.error('Error checking video exists:', error);
        return null;
    }
}
// Helper function to parse duration string to seconds
function parseDurationToSeconds(durationStr) {
    if (!durationStr)
        return 0;
    const parts = durationStr.split(':').map(Number);
    if (parts.length === 2) {
        return parts[0] * 60 + parts[1];
    }
    else if (parts.length === 3) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2];
    }
    return 0;
}
// Helper function to parse publish date
function parsePublishDate(dateStr) {
    if (!dateStr)
        return null;
    try {
        const date = new Date(dateStr);
        return isNaN(date.getTime()) ? null : date;
    }
    catch {
        return null;
    }
}
// Helper to get user usage for current month
async function getUserMonthlyUsage(userId) {
    const result = await sql `
    SELECT COALESCE(SUM(credits_used), 0) AS total
    FROM usage_tracking
    WHERE user_id = ${userId}
      AND action_type = 'video_processed'
      AND created_at >= date_trunc('month', now())
  `;
    return Number(result[0]?.total || 0);
}
// Update storeVideoAndSummary to accept creditsUsed and store it
async function storeVideoAndSummary(data, creditsUsed) {
    try {
        await ensureUserExists(data.userId, data.userEmail, data.userFullName);
        const publishDate = parsePublishDate(data.metadata.publishDate);
        if (!publishDate) {
            console.warn('Invalid publish date, using current date:', data.metadata.publishDate);
        }
        const videoResult = await sql `
      INSERT INTO videos (
        user_id, video_id, title, description, thumbnail_url, channel_title, duration, view_count, publish_date
      ) VALUES (
        ${data.userId}, ${data.videoId}, ${data.metadata.title}, ${data.metadata.description},
        ${data.metadata.thumbnailUrl}, ${data.metadata.channelTitle},
        ${parseDurationToSeconds(data.metadata.duration)},
        ${parseInt(data.metadata.viewCount) || 0},
        ${publishDate || new Date()}
      )
      ON CONFLICT (user_id, video_id) 
      DO UPDATE SET
        title = EXCLUDED.title,
        description = EXCLUDED.description,
        thumbnail_url = EXCLUDED.thumbnail_url,
        channel_title = EXCLUDED.channel_title,
        duration = EXCLUDED.duration,
        view_count = EXCLUDED.view_count,
        publish_date = EXCLUDED.publish_date
      RETURNING id
    `;
        const videoId = videoResult[0].id;
        const summaryResult = await sql `
      INSERT INTO video_summaries (
        video_id, main_title, overall_summary, raw_ai_output, transcript_sent, prompt_tokens, completion_tokens, total_tokens, input_cost, output_cost, total_cost, video_duration_seconds
      ) VALUES (
        ${videoId}, ${data.extraction.mainTitle}, ${data.extraction.overallSummary}, ${data.extraction.rawOpenAIOutput},
        ${data.extraction.transcriptSent}, ${data.extraction.promptTokens}, ${data.extraction.completionTokens},
        ${data.extraction.totalTokens}, ${data.extraction.inputCost}, ${data.extraction.outputCost},
        ${data.extraction.totalCost}, ${data.extraction.videoDurationSeconds}
      )
      ON CONFLICT (video_id) 
      DO UPDATE SET
        main_title = EXCLUDED.main_title,
        overall_summary = EXCLUDED.overall_summary,
        raw_ai_output = EXCLUDED.raw_ai_output,
        transcript_sent = EXCLUDED.transcript_sent,
        prompt_tokens = EXCLUDED.prompt_tokens,
        completion_tokens = EXCLUDED.completion_tokens,
        total_tokens = EXCLUDED.total_tokens,
        input_cost = EXCLUDED.input_cost,
        output_cost = EXCLUDED.output_cost,
        total_cost = EXCLUDED.total_cost,
        video_duration_seconds = EXCLUDED.video_duration_seconds
      RETURNING id
    `;
        // Store usage tracking with enhanced audit trail
        // Note: video_id and summary_id fields already exist in current database schema
        await sql `
      INSERT INTO usage_tracking (
        user_id, action_type, credits_used, video_id, summary_id
      ) VALUES (
        ${data.userId}, 'video_processed', ${creditsUsed}, ${videoId}, ${summaryResult[0].id}
      )
    `;
        return {
            videoId,
            summaryId: summaryResult[0].id
        };
    }
    catch (error) {
        console.error('Error storing video and summary:', error);
        throw new Error(`Failed to store video data: ${error.message}`);
    }
}
// 🔥 NEW TRANSACTIONAL VERSION - CRITICAL FIX FOR CREDIT SYSTEM
// This function ensures ALL operations succeed or ALL fail (atomicity)
async function storeVideoAndSummaryWithTransaction(data, creditsUsed) {
    try {
        // Ensure user exists before starting transaction
        await ensureUserExists(data.userId, data.userEmail, data.userFullName);
        const publishDate = parsePublishDate(data.metadata.publishDate);
        if (!publishDate) {
            console.warn('Invalid publish date, using current date:', data.metadata.publishDate);
        }
        // 🔐 MANUAL TRANSACTION SIMULATION: All operations with rollback on failure
        let videoId;
        let summaryId;
        let creditsConsumed = false;
        try {
            // 1. Insert/Update video data
            const videoResult = await sql `
        INSERT INTO videos (
          user_id, video_id, title, description, thumbnail_url, channel_title, duration, view_count, publish_date
        ) VALUES (
          ${data.userId}, ${data.videoId}, ${data.metadata.title}, ${data.metadata.description},
          ${data.metadata.thumbnailUrl}, ${data.metadata.channelTitle},
          ${parseDurationToSeconds(data.metadata.duration)},
          ${parseInt(data.metadata.viewCount) || 0},
          ${publishDate || new Date()}
        )
        ON CONFLICT (user_id, video_id) 
        DO UPDATE SET
          title = EXCLUDED.title,
          description = EXCLUDED.description,
          thumbnail_url = EXCLUDED.thumbnail_url,
          channel_title = EXCLUDED.channel_title,
          duration = EXCLUDED.duration,
          view_count = EXCLUDED.view_count,
          publish_date = EXCLUDED.publish_date
        RETURNING id
      `;
            videoId = videoResult[0].id;
            // 2. Insert/Update video summary
            const summaryResult = await sql `
        INSERT INTO video_summaries (
          video_id, main_title, overall_summary, raw_ai_output, transcript_sent, prompt_tokens, completion_tokens, total_tokens, input_cost, output_cost, total_cost, video_duration_seconds
        ) VALUES (
          ${videoId}, ${data.extraction.mainTitle}, ${data.extraction.overallSummary}, ${data.extraction.rawOpenAIOutput},
          ${data.extraction.transcriptSent}, ${data.extraction.promptTokens}, ${data.extraction.completionTokens},
          ${data.extraction.totalTokens}, ${data.extraction.inputCost}, ${data.extraction.outputCost},
          ${data.extraction.totalCost}, ${data.extraction.videoDurationSeconds}
        )
        ON CONFLICT (video_id) 
        DO UPDATE SET
          main_title = EXCLUDED.main_title,
          overall_summary = EXCLUDED.overall_summary,
          raw_ai_output = EXCLUDED.raw_ai_output,
          transcript_sent = EXCLUDED.transcript_sent,
          prompt_tokens = EXCLUDED.prompt_tokens,
          completion_tokens = EXCLUDED.completion_tokens,
          total_tokens = EXCLUDED.total_tokens,
          input_cost = EXCLUDED.input_cost,
          output_cost = EXCLUDED.output_cost,
          total_cost = EXCLUDED.total_cost,
          video_duration_seconds = EXCLUDED.video_duration_seconds
        RETURNING id
      `;
            summaryId = summaryResult[0].id;
            // 3. CONSUME CREDITS (only after data storage succeeds)
            const creditResult = await sql `
        UPDATE users 
        SET credits_used = credits_used + ${creditsUsed}
        WHERE id = ${data.userId}
        RETURNING credits_used
      `;
            creditsConsumed = true;
            // 4. Store usage tracking with audit trail
            await sql `
        INSERT INTO usage_tracking (
          user_id, action_type, credits_used, video_id, summary_id
        ) VALUES (
          ${data.userId}, 'video_processed', ${creditsUsed}, ${videoId}, ${summaryId}
        )
      `;
            // 5. Store video segments
            if (data.extraction.segments && data.extraction.segments.length > 0) {
                for (let i = 0; i < data.extraction.segments.length; i++) {
                    const segment = data.extraction.segments[i];
                    const startParts = segment.startTime.split(':');
                    const endParts = segment.endTime.split(':');
                    const startSeconds = parseInt(startParts[0]) * 60 + parseInt(startParts[1]);
                    const endSeconds = parseInt(endParts[0]) * 60 + parseInt(endParts[1]);
                    await sql `
            INSERT INTO video_segments (
              video_id, segment_number, title, start_time, end_time, hook, summary
            ) VALUES (
              ${videoId}, ${i + 1}, ${segment.title}, ${startSeconds}, ${endSeconds},
              ${segment.hook}, ${segment.narratorSummary}
            )
            ON CONFLICT (video_id, segment_number) 
            DO UPDATE SET
              title = EXCLUDED.title,
              start_time = EXCLUDED.start_time,
              end_time = EXCLUDED.end_time,
              hook = EXCLUDED.hook,
              summary = EXCLUDED.summary
          `;
                }
            }
            // 6. Store key takeaways
            if (data.extraction.keyTakeaways && data.extraction.keyTakeaways.length > 0) {
                for (let i = 0; i < data.extraction.keyTakeaways.length; i++) {
                    const takeaway = data.extraction.keyTakeaways[i];
                    await sql `
            INSERT INTO video_takeaways (
              video_id, takeaway, order_index
            ) VALUES (
              ${videoId}, ${takeaway}, ${i + 1}
            )
            ON CONFLICT ON CONSTRAINT unique_video_takeaway
            DO UPDATE SET
              takeaway = EXCLUDED.takeaway
          `;
                }
            }
            console.log(`✅ TRANSACTION SUCCESS: Video stored, credits consumed (${creditsUsed}), user: ${data.userId}`);
            return {
                videoId,
                summaryId,
                creditsUsed: creditResult[0].credits_used
            };
        }
        catch (error) {
            // If credits were consumed but other operations failed, attempt rollback
            if (creditsConsumed) {
                try {
                    await sql `
            UPDATE users 
            SET credits_used = credits_used - ${creditsUsed}
            WHERE id = ${data.userId}
          `;
                    console.log(`🔄 ROLLBACK: Credits refunded after failure for user ${data.userId}`);
                }
                catch (rollbackError) {
                    console.error(`❌ ROLLBACK FAILED: User ${data.userId} may have lost ${creditsUsed} credits`, rollbackError);
                }
            }
            throw error;
        }
    }
    catch (error) {
        console.error('❌ TRANSACTION FAILED: No credits consumed, no data stored:', error);
        throw new Error(`Transaction failed: ${error.message}`);
    }
}
// Function to fetch summaries for a user
async function getUserSummaries(userId) {
    try {
        const result = await sql `
      SELECT 
        v.id as id,
        v.title,
        vs.main_title,
        vs.created_at
      FROM videos v
      JOIN video_summaries vs ON v.id = vs.video_id
      WHERE v.user_id = ${userId}
      ORDER BY vs.created_at DESC
    `;
        return result;
    }
    catch (error) {
        console.error('Error fetching user summaries:', error);
        throw new Error(`Failed to fetch user summaries: ${error.message}`);
    }
}
// Function to delete a video summary
async function deleteVideoSummary(videoId, userId) {
    try {
        // First verify the video belongs to the user
        const videoCheck = await sql `
      SELECT id FROM videos
      WHERE id = ${videoId} AND user_id = ${userId}
    `;
        if (!videoCheck || videoCheck.length === 0) {
            throw new Error('Video not found or access denied');
        }
        // *** CRITICAL SECURITY FIX ***
        // Update usage_tracking records to preserve audit trail while removing video reference
        // This ensures credits remain consumed and audit trail is maintained
        await sql `
      UPDATE usage_tracking 
      SET video_id = NULL 
      WHERE video_id = ${videoId}
    `;
        // Now safely delete the video (and its summaries will cascade delete)
        await sql `
      DELETE FROM videos
      WHERE id = ${videoId} AND user_id = ${userId}
    `;
        // Log the deletion for audit purposes
        console.log(`✅ Video summary deleted for user ${userId}, video ${videoId}. Credits remain consumed (no refund policy).`);
        return { success: true };
    }
    catch (error) {
        console.error('❌ Error deleting video summary:', error);
        throw new Error(`Failed to delete summary: ${error.message}`);
    }
}
// Function to verify data storage
async function verifyVideoStorage(videoId, userId) {
    try {
        const result = await sql `
      SELECT 
        v.*,
        vs.main_title,
        vs.overall_summary,
        vs.raw_ai_output
      FROM videos v
      LEFT JOIN video_summaries vs ON v.id = vs.video_id
      WHERE v.video_id = ${videoId}
      AND v.user_id = ${userId}
    `;
        if (!result || result.length === 0) {
            return {
                success: false,
                message: 'Video data not found'
            };
        }
        return {
            success: true,
            data: result[0]
        };
    }
    catch (error) {
        console.error('Error verifying video storage:', error);
        return {
            success: false,
            message: `Error verifying storage: ${error.message}`
        };
    }
}
